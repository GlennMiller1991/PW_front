PIXEL WARS. Рабочая документация.

Пользователь заходит на сайт.
Пользователь может быть авторизованным и неавторизованным.
Пользователь проходит регистрацию в системе посредством входа через Google-аккаунт. После регистрации генерируется пара токенов - access и refresh для аутентификации и авторизации пользователя в системе в дальнейшем. Access-токен выдается на 15 минут по истечении которых после первого запроса к ресурсу, запрашивающего права, и следственно провалившегося, произойдет генерация новой пары ключей на основе refresh-токена, который действителен неделю.
Для регистрации требуется токен аккаунта Google пользователя с подтвержденной почтой, выданный на имя приложения. Токен ясен пончик должен быть завалидирован гуглом на сервере.
На данный момент пользователи остаются в системе до перезапуска сервера, хотя в будущем потребуется более постоянное хранилище, но это задача с меньшим приоритетом.
Итак, пользователь может быть авторизован и неавторизован.
Авторизованный пользователь может играть, неавторизованный пользователь может только просматривать игру.
Неавторизованный пользователь по кулдауну (5сек?) запрашивает предыдущий снимок битмапы. Снимок битмапы делается каждые N версий. Снимок сжимается и в таком виде отправляется. Фронт снимок разжимает и рендерит. Допустим полный спектр линейных трансформаций, но без установки пикселя. Любой хак должен валидироваться на стороне сервера естественно.
Авторизованный пользователь может находиться в четырех состояниях - условно AFK, в очереди на игру, затупивший и играющий.
Играющий пользователь - это пользователь, у которого с момента последнего игрового действия прошло не более двух минут.
AFK пользователь - это пользователь, у которого с момента последнего игрового действия прошло более двух минут.
Пользователь в очереди - это пользователь, который ожидает перевода в статус играющего. Данный вариант возможен в случае большой нагрузки на сервер. Очередь есть всегда, но иногда она пустая.
Алгоритм перевода примерно следующий - пользователь встает в очередь, как только сервер будет готов пользователя впустить, тот переводится в статус играющего. По истечении двух минутут переводится в статус AFK из которого выводится явным действием пользователя. Возможно в принципе нужно явное действие пользователя с самого начала.
Каждый статус реагирует на изменения состояния битмапы по своему.
Играющий - ставит пиксель, отправляет его по http, ждет сообщения по ws. Чистый real-time.
В очереди - предполагается что так же, как и играющий, но не имеет возможности поставить пиксель.
AFK - то же, что и неавторизованный юзер.

Битмапа. Каждое действие инкрементирует версию битмапы. Каждые N(100?) версий делается снимок битмапы и сжимается для отправки. Доступ к битмапе осуществляется по очереди с приоритетом на чтение. Планирую сделать типа через промисы. То есть, приходит запрос на запись, и пока запись происходит, могут придти запросы на чтение и еще на запись. После выполненной записи осуществляется чтение, и потом снова запись и так далее. Будет типа связный список промисов.
Фронт считает версию. Если пришла не та версия, которую фронт ожидал, то фронт сначала делает запрос за изменением версии (или списка версий), после чего начинает применять изменения из сообщений, которые до тех пор, если приходили, складывались в очередь. Если версии нет в пуле, то отдается последний снимок битмапы и изменения до запрашиваемой версии. Пока что в пуле сотня версий, но вероятно пул будет динамическим в зависимости от нагрузки, размеров битмапы и др.

Необходимо сделать страницу обратной связи. Подвязать телегу для возможности очистить холст (обязяательно). Валидировать запросы не с фронта (в этом нет ничего плохого, просто нельзя позволять слать сотню rps). Валидация ws соединения.
Сервис, делающий снимки для истории. Ну и конечно сервис, ведущий трансляцию на ютубе?? В общем-то весь фронт - одна большая задача: лого, дизайн, архитектура, разные устройства; затем, pwa/tg/store.

Отсюда следует, что любой пользователь, находящийся в статусе играющего, либо ожидающего игры, должен держать канал вебсокетов. Итак, юзер нажимает Играть, пошел запрос на создание соединения. То есть активные игроки хранятся в памяти сервера. Каждый активный игрок представляет собой совокупность сокета, айдишника сессии, статуса, времени последнего игрового действия. Сообщения рассылаются каждому активному игроку. Игровые действия принимаются только от активных игроков в статусе играющий. Когда запрос на создание сокет соединения приходит что должно происходить?
Есть несколько вариантов - держать задачу на бэкграунде, которая условно раз в минуту актуализирует активность. Актуализировать активность в момент рассылки. Держать задачу на бэкграунде для каждого играющего - своего рода дебаунс в 2 минуты, который продляется после игрового действия.
Есть мысль сделать так - существует одна задача, выполнение которой планируется. Планирование происходит в момент любого игрового действия. Пришло первое игровое действие, создается задача по выводу пользователя, отправившего ее, из игры через 2 минуты. Все последующие действия будут позже, поэтому задача выполняется через 2 минуты, проверяет актуальность, на основе чего выполняется или не выполняется логика актуализации, анализируются активные пользователи, на основе чего планируется следующая ближайшая задача. И так дальше, пока остаются пользователи.


В случае если соединение сокета неактивно - бэк не может быть уверен, что пользователь покинул сайт, равно как и сайт не всегда может уведомить сервер перед покиданием. Поэтому логичнее будет сразу не завязываться на это поведение. Логика должна быть общей для всех без исключения кейсов.
Например, у пользователя по прежнему есть две минуты, чтобы восстановить соединение, иначе он переведется в AFK - то есть в принципе не будет отслеживаться. В случае, если фронт например затупил, и юзер перезагружает страницу, что должно происходить?
Порассуждаем, юзер перезагрузился, на бэк ушел токен обновления, бэк создал новую пару токенов, инкрементировал сессию, проверил активных пользователей, нашел там того же чела, но с устаревшей сессией. Не меняя время последнего игрового действия актуализировал данные о нем, и юзер продолжил играть. Если юзера там нет, то пользователю назначается статус AFK и он не отслеживается.

AwayFromKeyboard и очередь.
Кто должен следить за этими статусами?
Очевидно бэк должен наглухо закрывать соединение, отправляя перед этим сообщение о смене статуса. На фронте пришло сообщение, о смене статуса (кстати, статус может меняться только afk -> очередь -> игра -> afk -> ...) на АФК, значит сокет соединение сейчас закроется, может превентивно его закрыть. Обновляем фронт и модель запроса данных (кулдауны и http). Юзер жмякает Играть - создается сокет соединение, пользователь сторится в памяти, статус его известен, нужно время захода в очередь. Возможно имеет смысла иметь отдельную задачу по переводу пользователей из очереди в играющих по тому же принципу, что и актуализация из играющих в АФК - это логично вообще. Когда пользователь выходит из очереди, ему по вс отправляется сообщение о смене статуса. и все - можно жмякать на кнопочки.

Безопасность сокетсоединения. Если порассуждать, то вспомним, что сокет соединеие может создаться только для залогиненных пользователей. Как минимум раз в 15 минут будет приходить запрос на обнволение токена с инкрементацией сессии, актуализацией игровой записи. Кроме того, сокеты планируется использовать только для рассылки сообщений клиентам, сервер соединение читать не будет в принципе. Со стороны кажется априори довольно безопасно. Но нужно будет проконсультироваться.


Задачи.
Разобраться с сокет соединением на телефоне.
Реализовать логику смены статусов, разобраться с ориджинами в запросах к гуглу, чтобы можно было затестить на двух устройствах. Если нет, то выпилить пока что авторизацию в гугле и завязаться на айпи или снимок устройства. Затестить.
Задача по переводу из играющего в афк, это самое важное.
Восстановление сессии.
Задача по переводу из очереди в играющие. Логика очереди в принципе - насколько большая она может быть, насколько много играющих, как мониторить нагрузку (отправляемые байты в сек?)
Очередь на изменение битмапы - запись/чтение. Версионность.
Пропуск версии и запрос с фронта к неактуальной версии.
Хранение версий, снимки битмапы и компрессия. Восстановление на фронте.
Лого.
Трансформация игрового поля. Стили трансформации
Выбор цвета и ячейки. Может быть завязка на зум.
Красивенькая и логичная смена статусов.
Страница обратной связи.
Телеграм: команда на начало новой игры и затирание холста.
Деплой.
Трансляция на ютуб из снимков битмапы.
???
Давай сначала дойдем, если хоть какой-то взлет будет, то здесь будет задача по охуенной правке багов.

